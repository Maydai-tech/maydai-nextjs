---
description:
globs:
alwaysApply: false
---
# Authentication Patterns

## Standardized Auth Patterns

The app uses 3 standardized authentication patterns based on page type and requirements.

### 1. Auth Pages Pattern (`isCheckingAuth`)
For login/signup pages - simple and direct approach.

```typescript
const { user, loading } = useAuth()
const [isCheckingAuth, setIsCheckingAuth] = useState(true)

useEffect(() => {
  if (!loading) {
    if (user) {
      router.push('/dashboard')
    } else {
      setIsCheckingAuth(false)
    }
  }
}, [user, loading, router])

if (loading || isCheckingAuth) {
  return <LoadingComponent />
}
```

### 2. Protected Pages Pattern (`mounted + loading`)
For dashboard, usecases, profile pages - robust for SSR and data management.

```typescript
const { user, loading } = useAuth()
const [mounted, setMounted] = useState(false)

useEffect(() => {
  setMounted(true)
}, [])

useEffect(() => {
  if (mounted && !loading && !user) {
    router.push('/login')
  }
}, [user, loading, router, mounted])

if (!mounted || loading) {
  return <LoadingComponent />
}

if (!user) {
  return null
}
```

### 3. Admin Pages Pattern (ProtectedRoute)
Centralized and reusable for admin sections.

```typescript
export default function AdminPage() {
  return (
    <ProtectedRoute requiredRole="admin">
      {/* Admin content */}
    </ProtectedRoute>
  )
}
```

### Files Involved
- Auth hook: [lib/auth.tsx](mdc:lib/auth.tsx)
- Protected route component: [components/ProtectedRoute.tsx](mdc:components/ProtectedRoute.tsx)
- Example implementations in dashboard and usecase pages

## Key Requirements
- **SSR Compatibility**: Always use `mounted` state
- **Loading States**: Show consistent loaders
- **Automatic Redirects**: No manual auth checks in components
- **Responsive Design**: All auth flows work on mobile/tablet

## Critical Rules
- **Always use `mounted` state** for SSR compatibility
- **Consistent loading states** across all pages
- **Auto-redirects only** - no manual auth checks in components

- **Pattern 2** (`mounted + loading`) is the most secure as it prevents SSR hydration vulnerabilities
- Always use defensive programming: assume content should be hidden by default
- Client-side authentication is for UX only - real security must be enforced server-side
- Use the `useAuth` hook from [lib/auth.tsx](mdc:lib/auth.tsx) for all authentication logic
